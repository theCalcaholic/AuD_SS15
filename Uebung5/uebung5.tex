\documentclass[fleqn]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{lipsum}
\usepackage{ulem}
\usepackage{comment}
\usepackage{enumerate}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{parallel}

\lstset{
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bfseries\ttfamily\color{orange},
  stringstyle=\color{green}\ttfamily,
  commentstyle=\color{middlegray}\ttfamily,
  emph={square}, 
  emphstyle=\color{blue}\texttt,
  emph={[2]root,base},
  emphstyle={[2]\color{yac}\texttt},
  showstringspaces=false,
  flexiblecolumns=false,
  tabsize=2,
  numbers=left,
  numberstyle=\tiny,
  numberblanklines=false,
  stepnumber=1,
  numbersep=6pt,
  xleftmargin=15pt,
  literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\date{\gertoday}

\lhead{\@author}
\chead{}
\rhead{\gertoday}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\setlength{\mathindent}{0pt}

\usepackage[x11names, rgb]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{lipsum}
\usepackage{ulem}
\usepackage{comment}
\usepackage{enumerate}
\usepackage{titlesec}
\usepackage{boolexpr,pdftexcmds,trace}
\makeatletter

\tikzset{>=latex} 
\usetikzlibrary{snakes,arrows,shapes,positioning}
\newwrite\dotfile

\begingroup
  \catcode`\[ = 1\relax
  \catcode`\] = 2\relax
  \catcode`\{ = 12\relax
  \catcode`\} = 12 \relax
  \gdef\OpenBrace[{]
  \gdef\CloseBrace[}]
\endgroup

% custom commands
\newcommand{\leadingzero}[1]{\ifnum #1<10 0#1\else#1\fi}
\newcommand{\gerdate}[3]{\leadingzero{#1}.\leadingzero{#2}.\leadingzero{#3}}
\newcommand{\gertoday}{\gerdate{\the\day}{\the\month}{\the\year}}
\newcommand*{\bfrac}[2]{\genfrac{}{}{0pt}{}{#1}{#2}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\dotarrow}[0]{}

\newenvironment{graphviz}[1]%
{%
\switch
\case{\pdf@strcmp{#1}{graph}}
    \renewcommand{\dotarrow}[0]{--}
\case{\pdf@strcmp{#1}{strict graph}}
    \renewcommand{\dotarrow}[0]{--}
\case{\pdf@strcmp{#1}{digraph}}
    \renewcommand{\dotarrow}[0]{->}
\case{\pdf@strcmp{#1}{strict digraph}}
    \renewcommand{\dotarrow}[0]{->}
\endswitch

\immediate\openout\dotfile=tmp.dot%
\newcommand{\node}[2]{%
\immediate\write\dotfile{##1 \dotarrow \OpenBrace##2\CloseBrace}%
}%
%
\immediate\write\dotfile{#1 \OpenBrace}
}%
{\immediate\write\dotfile{\CloseBrace}%
\immediate\closeout\dotfile%
\immediate\write18{dot2tex --figonly tmp.dot > tmp.tex}%
\input{tmp.tex}%
}

\setcounter{section}{0}
\setcounter{subsection}{0}
\pagestyle{fancy}

\lhead{}
\chead{}
\rhead{\gertoday}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\setlength{\mathindent}{0pt}

% document specific settings and formats
% set consecutive page number
\newcommand\pagenum{5}
% set title (only change date)
\title{Algorithmen \& Datenstrukturen - Aufgaben zum \\7. Dezember 2015 (Blatt \leadingzero{\pagenum})}
% set authors
\author{Tobias Knöppler}

\renewcommand{\thesection}{\pagenum.\arabic{section}}
\renewcommand{\thesubsection}{~~\arabic{subsection}.}
\renewcommand{\thesubsubsection}{\roman{subsubsection})}
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}


\author{Tobias Knöppler (6523815), Nico Tress (6378086)}
\date{\gertoday}
\begin{document}
\maketitle

\section{}
\subsection{}%subsection name}\label{label}

\begin{enumerate}[i)]
\item 
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]

  \node[elem] (0) {5};
\end{tikzpicture}

\item 
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]

  \node[elem] (n0) {5};
  \node[elem] (n1)
    [below right=5mm and 5mm of n0.south] 
    {8} 
    edge (n0);
\end{tikzpicture}

\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]

  \node[elem] (n0) {5};
  \node[elem] (n1)
    [below right=5mm and 5mm of n0.south] 
    {8} 
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 5mm of n1.south]
    {9}
    edge (n1);
\end{tikzpicture}

\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]

  \node[elem] (n0) {5};
  \node[elem] (n1)
    [below right=5mm and 5mm of n0.south] 
    {8} 
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 5mm of n1.south]
    {9}
    edge (n1);
  \node[elem] (n3)
    [below left=5mm and 5mm of n1.south]
    {6}
    edge (n1);
\end{tikzpicture}

\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]

  \node[elem] (n0) {5};
  \node[elem] (n1)
    [below right=5mm and 5mm of n0.south] 
    {8} 
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 5mm of n1.south]
    {9}
    edge (n1);
  \node[elem] (n3)
    [below left=5mm and 5mm of n1.south]
    {6}
    edge (n1);
  \node[elem] (n4)
    [below right=5mm and 5mm of n3.south]
    {7}
    edge (n3);
\end{tikzpicture}
\end{enumerate}

\subsection{}%subsection name}\label{label}
\begin{enumerate}[i)]
\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]
  \node[elem] (n0)
    {20};
  \node[elem] (n1)
    [below left=5mm and 15mm of n0.south]
    {10}
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 15mm of n0.south]
    {25}
    edge (n0);
  \node[elem] (n3)
    [below left=5mm and 5mm of n1.south]
    {7}
    edge (n1);
  %\node[elem] (n4)
  %  [below right=5mm and 5mm of n1.south]
  %  {14}
  %  edge (n1);
  \node[elem] (n5)
    [below left=5mm and 5mm of n2.south]
    {22}
    edge (n2);
  \node[elem] (n6)
    [below right=5mm and 5mm of n2.south]
    {27}
    edge (n2);
  \node[elem] (n7)
    [below left=5mm and 5mm of n5.south]
    {21}
    edge (n5);
  \node[elem] (n8)
    [below right=5mm and 5mm of n5.south]
    {24}
    edge (n5);
  \node[elem] (n9)
    [below right=5mm and 5mm of n6.south]
    {29}
    edge (n6);
  \node[elem] (n10)
    [below left=5mm and 5mm of n9.south]
    {28}
    edge (n9);
  \node[elem] (n11)
    [below right=5mm and 5mm of n9.south]
    {31}
    edge (n9);
\end{tikzpicture}

\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]
  \node[elem] (n0)
    {20};
  \node[elem] (n1)
    [below left=5mm and 15mm of n0.south]
    {10}
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 15mm of n0.south]
    {25}
    edge (n0);
  \node[elem] (n3)
    [below left=5mm and 5mm of n1.south]
    {7}
    edge (n1);
  %\node[elem] (n4)
  %  [below right=5mm and 5mm of n1.south]
  %  {14}
  %  edge (n1);
  \node[elem] (n5)
    [below left=5mm and 5mm of n2.south]
    {22}
    edge (n2);
  %\node[elem] (n6)
  %  [below right=5mm and 5mm of n2.south]
  %  {27}
  %  edge (n2);
  \node[elem] (n7)
    [below left=5mm and 1mm of n5.south]
    {21}
    edge (n5);
  \node[elem] (n8)
    [below right=5mm and 1mm of n5.south]
    {24}
    edge (n5);
  \node[elem] (n9)
    [below right=5mm and 5mm of n2.south]
    {29}
    edge (n2);
  \node[elem] (n10)
    [below left=5mm and 1mm of n9.south]
    {28}
    edge (n9);
  \node[elem] (n11)
    [below right=5mm and 1mm of n9.south]
    {31}
    edge (n9);
\end{tikzpicture}

\item
\begin{tikzpicture}[<-]
  \tikzstyle{elem} = [rectangle, draw]
  \node[elem] (n0)
    {20};
  \node[elem] (n1)
    [below left=5mm and 15mm of n0.south]
    {10}
    edge (n0);
  \node[elem] (n2)
    [below right=5mm and 15mm of n0.south]
    {24}
    edge (n0);
  \node[elem] (n3)
    [below left=5mm and 5mm of n1.south]
    {7}
    edge (n1);
  %\node[elem] (n4)
  %  [below right=5mm and 5mm of n1.south]
  %  {14}
  %  edge (n1);
  \node[elem] (n5)
    [below left=5mm and 5mm of n2.south]
    {22}
    edge (n2);
  %\node[elem] (n6)
  %  [below right=5mm and 5mm of n2.south]
  %  {27}
  %  edge (n2);
  \node[elem] (n7)
    [below left=5mm and 1mm of n5.south]
    {21}
    edge (n5);
  %\node[elem] (n8)
  %  [below right=5mm and 1mm of n5.south]
  %  {24}
  %  edge (n5);
  \node[elem] (n9)
    [below right=5mm and 5mm of n2.south]
    {29}
    edge (n2);
  \node[elem] (n10)
    [below left=5mm and 1mm of n9.south]
    {28}
    edge (n9);
  \node[elem] (n11)
    [below right=5mm and 1mm of n9.south]
    {31}
    edge (n9);
\end{tikzpicture}
\end{enumerate}

\section{}%section name}\label{label}
\subsection{}%subsection name}\label{label}
\begin{lstlisting}
InorderTreeWalk(x)
  for each sibling n of x
    n.color = white
  
  while x.color == white or right[x].color == white
    if left[x] != nil and left[x].color == white
      x = left[x]
    else
      if x.color == white
        print key[x]
        x.color = black
      if right[x] != nil and right[x].color == white
        x = right[x]
\end{lstlisting}
\subsection{}%subsection name}\label{label}

\begin{lstlisting}
TreeMinimum(x)
  if links[x] == nil
    return x
  else
    return TreeMinimum(left[x])
\end{lstlisting}

\section{}%section name}\label{label}
\begin{enumerate}[I]
  \item Ein Pfad hat maximal die Länge $n-1$, wobei n die Anzahl Knoten ist, die er durchläuft.
  \item Wenn es in einem Graphen G zwei Knoten s und t gibt, die durch einen oder mehrere  Pfade verbunden sind, so gibt es genau dann einen Knoten v, bei dessen Entfernung alle Pfade von s nach t unterbrochen würden, wenn all diese Pfade v enthalten.
  \item Angenommen, G sei ein Graph mit n Knoten. s und t seien 2 Knoten in G, zweischen denen es 2 Pfade p, q mit $|p|,|q| > \frac{n}{2}$ gibt, die außer s und t keine Knoten gemeinsam haben. Dann enthält der kleinere Pfad von p und q außer s und t maximal $\frac{n}{2}$, also $\frac{n - 2}{2} + 2$ Knoten (nämlich dann, wenn p und q jeweils genau die Hälfte der übrigen Knoten enthalten) und hat wegen $I$ damit eine maximale Länge von $\frac{n - 2}{2} + 1 = \frac{n}{2}$.\\
  Damit ist die Annahme, dass $|p|,|q| > \frac{n}{2}$ zum Widerspruch geführt und bewiesen, dass zwei Pfade, die s und t verbinden und länger als $\frac{n}{2}$ sind, mindestens einen Knoten gemeinsam haben müssen.
  \item Aus $II$ und $III$ folgt, dass es in einem Graphen mit n Knoten, der zwei Knoten s und t enthält, deren Distanz $> \frac{n}{2}$ ist, einen Knoten v geben muss, der allen Pfaden zweischen s und t gemein ist, wodurch durch Löschen von v alle Pfade zwischen s und t zerstört werden. $\square$
\end{enumerate}

\section{}%section name}\label{label}
\begin{lstlisting}
FindV(s, t, V)
  for each n in V
    n.counter = 0
    n.color = white
  s.color = black
  
  for each n in adjacents(s)
    CheckPath(n, t)
    
  v = random node in V
  for each n in V
    if v.counter < n.counter
      v = n
  
  return v
  
  
CheckPath(n, t)
  
  if n == t
    return 1

  n.color = grey
  for each m in adjacents(n)
    if m.color == white 
      number_of_paths = CheckPath(m, t)
      n.counter = n.counter + number_of_paths
  m.color = white
  
  return n.counter
  
\end{lstlisting}

FindV durchläuft die Knoten in G in einer Tiefensuche, ausgehend von den angrenzenden Knoten von s. Dabei wird für jeden Knoten überprüft, ob von diesem ein oder mehrere Pfade zu t führen; falls dies der Fall ist, so wird der Counter des aktuellen Knotens um 1 für jeden gefundenen Pfad zu t erhöht (Z. 26-27). \\
Dabei wird entgegen einer üblichen Tiefensuche ein bereits besuchter Knoten nicht als besucht markiert, sondern nachdem alle von diesem Knoten ausgehenden Pfade untersucht wurden, wird er wieder weiß markiert. Das hat zur Folge, dass, sollte ein weiterer Pfad zu dem knoten hinführen, dessen Counter ein weiteres Mal um die Anzahl der Pfade, die von diesem Knoten zu t führen erhöht wird.\\
Die endgültige Zahl von v.counter entspricht also der Zahl der Pfade, die von s zu v führen multipliziert mit der Anzahl der Pfade, die von v zu t führen. Insgesamt ist dies die Anzahl der Pfade von s nach t, auf denen v liegt.\\
Damit ist es dann nur noch notwendig, den Knoten mit dem höchsten Counter zu finden; dieser liegt auf den meisten Pfaden von s nach t und wie weiter oben gezeigt, müssen dies alle Pfade von s nach t sein, sofern die Distanz von s zu t größer ist als $\frac{n}{2}$.\\
Sollte es mehrere Knoten mit demselben (höchsten) Counter geben, so liegen diese alle auf allen Pfaden von s nach t und es ist irrelevant, welchen davon man wählt.\\

\section{}%section name}\label{label}
\subsection{}%subsection name}\label{label}

Das Problem Big-Clique lässt sich auf 2CNF reduzieren, indem man analog zur Reduktion von Clique auf 3CNF aus einer aussagenlogischen Formel F in konjunktiver Normalform, die jeweils 2 Literale pro Klausel enthält, einen Graphen G konstruiert.\\
Dabei geht man folgendermaßen vor: für jedes Symbol in F füge man einen Knoten zu G hinzu. Nun verbinde man alle Knoten, die nicht in derselben Klausel stehen und denen nicht einander ausschließende Literale zugeordnet sind (z.B. $\neg x$ und $x$).\\
Die Anzahl der Klauseln entspricht exakt $\frac{n}{2}$, da jede Klausel zwei Literale enthält.\\
Dann gibt es genau dann eine $\frac{n}{2}$-Clique in G, wenn F erfüllbar ist. Die wahr gemachten Literale entsprechen den Knoten in der Clique. Dies gilt wegen des Konstruktionsverfahrens für G aus F: Weil nur solche Knoten verbunden sind, deren Symbole sich nicht gegenseitig ausschließen, ist es \textit{möglich}, alle Symbole von durch Kanten verbundenen Knoten wahr zu machen. Da nur Knoten verbunden sind, deren Symbole nicht in derselben Klausel stehen, ist die CNF automatisch erfüllt, wenn man alle zu den Knoten einer $\frac{n}{2}$-Clique gehörigen Symbole wahr macht.\\
Da es auf die beschriebene Weise möglich ist, Big-Clique in Polynomialzeit auf 2CNF zu reduzieren, ist Big-Clique in NPC, da auch 2CNF in NPC ist.


\end{document}
